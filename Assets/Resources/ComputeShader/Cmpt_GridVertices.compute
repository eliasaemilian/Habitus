#pragma kernel GenGridVertices
#pragma kernel GenMeshBorder
#define NUM_THREADS  ( 8 )

struct Vertex
{
    float4 pos; //xyz = pos, w = terrain type
};

struct Hexagon
{
    float4 center; //xyz = center pos, w = terrain type
    float4 tesselation;
    float3 topverts[6];
};




RWStructuredBuffer<Hexagon> HexInput;
RWStructuredBuffer<Vertex> Vertices; // OUT
//ConsumeStructuredBuffer<uint> ActiveIDs;
AppendStructuredBuffer<Vertex> ActiveVerticesOut;

float4 _Size;
#define GRID_SIZE_X     ( (uint)_Size.x )
#define GRID_SIZE_Y     ( (uint)_Size.y )
#define HEX_RADIUS      ( _Size.z ) 
#define HEX_WIDTH       ( _Size.w ) 



void AddTriangle( inout uint n, float type, float3 a, float3 b, float3 c )
{
    Vertices[n].pos.xyz = a;
    Vertices[n].pos.w = type;
    
    Vertices[n + 1].pos.xyz = b;
    Vertices[n + 1].pos.w = type;

    Vertices[n + 2].pos.xyz = c;
    Vertices[n + 2].pos.w = type;

    n += 3;
}

void AddTriangle( float type, float3 a, float3 b, float3 c )
{
    Vertex v;
    v.pos = float4( a, type );
    ActiveVerticesOut.Append( v );
    
    v.pos = float4( b, type );
    ActiveVerticesOut.Append( v );
    
    v.pos = float4( c, type );
    ActiveVerticesOut.Append( v );
}



void AddTessFullQuad( inout uint n, float type, float3 t, float3 te[4] ) // right, down, left, up with t as middle point, 15 verts
{
    for ( uint i = 0; i < 3; i++ )
    {
        AddTriangle( n, type, t, te[i], te[i + 1] );
    }
    AddTriangle( n, type, t, te[i], te[0] );
}

void AddTessFullQuad( inout uint n, float type, float3 t, float3 r, float3 rd, float3 d, float3 dl, float3 l, float3 lu, float3 u, float3 ur ) // right, down, left, up with t as middle point
{
    AddTriangle( n, type, t, r, rd );
    AddTriangle( n, type, t, rd, dl );
    AddTriangle( n, type, dl, rd, d );
    AddTriangle( n, type, rd, r, d );
    AddTriangle( n, type, t, dl, l );
    AddTriangle( n, type, dl, d, l );
    AddTriangle( n, type, t, l, lu );
    AddTriangle( n, type, l, u, lu );
    AddTriangle( n, type, t, lu, ur );
    AddTriangle( n, type, lu, u, ur );
    AddTriangle( n, type, t, ur, r );
    AddTriangle( n, type, u, r, ur );
}

void AddTessTopHalf( inout uint n, float type, float3 t, float3 r, float3 d, float3 l )
{
    AddTriangle( n, type, t, r, d );
    AddTriangle( n, type, t, d, l );
}

void AddTessTopHalf( inout uint n, float type, float3 t, float3 r, float3 rd, float3 d, float3 dl, float3 l )
{
    AddTriangle( n, type, t, r, rd );
    AddTriangle( n, type, t, rd, d );
    AddTriangle( n, type, t, d, dl );
    AddTriangle( n, type, t, dl, l );
}

void AddTessBottomHalf( inout uint n, float type, float3 t, float3 r, float3 l, float3 u )
{
    AddTriangle( n, type, t, u, r );
    AddTriangle( n, type, t, l, u );
}

void AddTessBottomHalf( inout uint n, float type, float3 t, float3 r, float3 l, float3 lu, float3 u, float3 ur )
{
    AddTriangle( n, type, t, l, lu );
    AddTriangle( n, type, t, lu, u );
    AddTriangle( n, type, t, u, ur );
    AddTriangle( n, type, t, ur, r );
}

groupshared uint cT0, cT1;

[numthreads( NUM_THREADS, NUM_THREADS, 1 )]
void GenGridVertices( uint3 id : SV_DispatchThreadID )
{
    cT0 = 0;
    cT1 = 0;
    
    uint n;
      
    float r = HEX_RADIUS;
    float hr = r * .5;
    float hhr = hr * .5;

    float w = HEX_WIDTH;
    float hw = w * .5;
    float hhw = hw * .5;
            
    uint hid = id.x + id.y * GRID_SIZE_X;    
    if ( id.x > GRID_SIZE_X || id.y > GRID_SIZE_Y || hid > GRID_SIZE_X * GRID_SIZE_Y )
        return;
   
           
    float3 c = HexInput[hid].center.xyz;
    float type = HexInput[hid].center.w;

    
    // Hex Verts
    float3 verts[6] =
    {
        float3( c.x + r, c.y, c.z ),
        float3( c.x + hr, c.y, c.z - w ),
        float3( c.x - hr, c.y, c.z - w ),
        float3( c.x - r, c.y, c.z ),
        float3( c.x - hr, c.y, c.z + w ),
        float3( c.x + hr, c.y, c.z + w )
    };     
    HexInput[hid].topverts = verts;
        
    // Tesselation Factor 1 
    float3 t1[4] =
    {
        float3( c.x + hr, c.y, c.z ),
        float3( c.x - hr, c.y, c.z ),
        float3( c.x, c.y, c.z - w ),
        float3( c.x, c.y, c.z + w )
    };
       
        
        // Hex Indices
        
     // Factor 0
    for ( uint j = 0; j < HexInput[hid].tesselation.x; j++ ) // 18 Verts
    {
        n = ( cT0 * ( hid * 18 ) ) + ( cT1 * ( hid * 36 ) );

        for ( uint k = 0; k < 5; k++ )
        {
            AddTriangle( n, type, verts[k], verts[k + 1], c );
        }
        AddTriangle( n, type, verts[0], c, verts[5] );
        
        cT0++;
    }
         
    
    // Factor 1
    for ( j = 0; j < HexInput[hid].tesselation.y; j++ )
    {
        n = ( cT0 * ( hid * 18 ) ) + ( cT1 * ( hid * 36 ) );
        
        float3 a[4] = { verts[0], verts[1], c, verts[5] };
        float3 b[4] = { c, verts[2], verts[3], verts[4] };
        AddTessFullQuad( n, type, t1[0], a );
        AddTessFullQuad( n, type, t1[1], b );

        AddTessBottomHalf( n, type, t1[2], verts[1], verts[2], c );
        AddTessTopHalf( n, type, t1[3], verts[5], c, verts[4] );
        
        cT1++;
    }

    //Factor 2  
    float3 t2[8] =
    {
        float3( t1[0].x + hhr, c.y, t1[0].z - hhw ), //a -> 0
            float3( t1[1].x - hhr, c.y, t1[1].z - hhw ), //c -> 1
            float3( t1[1].x - hhr, c.y, t1[1].z + hhw ), //d -> 2
            float3( t1[0].x + hhr, c.y, t1[0].z + hhw ), //f -> 3
            float3( c.x + hhr, c.y, c.z - hhw ), //g -> 4
            float3( c.x - hhr, c.y, c.z - hhw ), //h -> 5
            float3( c.x - hhr, c.y, c.z + hhw ), //i -> 6
            float3( c.x + hhr, c.y, c.z + hhw ), //j -> 7                           
    };
        
    for ( j = 0; j < HexInput[hid].tesselation.z; j++ )
    {
        n = hid * 96;
        
        AddTessFullQuad( n, type, t1[0], verts[0], t2[0], verts[1], t2[4], c, t2[7], verts[5], t2[3] );
        AddTessFullQuad( n, type, t1[1], c, t2[5], verts[2], t2[1], verts[3], t2[2], verts[4], t2[6] );

        AddTessBottomHalf( n, type, t1[2], verts[1], verts[2], t2[5], c, t2[4] );
        AddTessTopHalf( n, type, t1[3], verts[5], t2[7], c, t2[6], verts[4] );
    }
     
    
}


RWStructuredBuffer<Vertex> BorderVertices;

[numthreads( NUM_THREADS, NUM_THREADS, 1 )]
void GenMeshBorder( uint3 id : SV_DispatchThreadID )
{
    uint hid = id.x + id.y * GRID_SIZE_X;
    if ( id.x > GRID_SIZE_X || id.y > GRID_SIZE_Y || hid > GRID_SIZE_X * GRID_SIZE_Y )
        return;
    
    uint n = hid * 36;
        
    float3 botverts[6];
    for ( uint i = 0; i < 6; i++ )
        botverts[i] = float3( HexInput[hid].topverts[0].x, 0, HexInput[hid].topverts[0].z );
    
    // gen indices
           // sides
    for ( i = 0; i < 4; i++ )
    {
        BorderVertices[n].pos.xyz = HexInput[hid].topverts[i];
        BorderVertices[n + 1].pos.xyz = botverts[i + 1];
        BorderVertices[n + 2].pos.xyz = HexInput[hid].topverts[i + 1];

        BorderVertices[n + 3].pos.xyz = botverts[i + 1];
        BorderVertices[n + 4].pos.xyz = botverts[i + 2];
        BorderVertices[n + 5].pos.xyz = HexInput[hid].topverts[i + 1];

        n += 6;
    }
    
    BorderVertices[n].pos.xyz = botverts[5];
    BorderVertices[n + 1].pos.xyz = HexInput[hid].topverts[0];
    BorderVertices[n + 2].pos.xyz = HexInput[hid].topverts[5];

    BorderVertices[n + 3].pos.xyz = HexInput[hid].topverts[0];
    BorderVertices[n + 4].pos.xyz = botverts[5];
    BorderVertices[n + 5].pos.xyz = botverts[0];
        
    // fill vetices buffer with indices
}