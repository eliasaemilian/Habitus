// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


struct Vertex
{
    float3 pos;
    int type; // = TerrainType
};

struct Hexagon
{
    float3 center;
};

StructuredBuffer<Hexagon> Hex;
StructuredBuffer<Vertex> HexVertices; // IN
RWStructuredBuffer<Vertex> Vertices; // OUT

int hexWidth = 10;
int hexHeight = 10; // Debug Numbers width 10, -> segments 5

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    
    // TODO: 
    
    uint vert = 0;
    
    float w = hexWidth * .5;
    float hw = w * .5;
    float r = hexHeight * .5;
    float hr = r * .5;

    // for each center hex tesselate with width / heigth
    uint count = 0;
    uint stride = 0;
    Hex.GetDimensions( count, stride );
    // for each vertex in hex buffer
    for ( uint i = 0; i < count; i++ )
    {
        float3 c = Hex[i].center;
        
        // Hex Verts
        float3 verts[6] = 
        {
            float3( c.x + r, c.y, c.z ),
            float3( c.x + hr, c.y, c.z - w ),
            float3( c.x - hr, c.y, c.z - w ),
            float3( c.x - r, c.y, c.z ),
            float3( c.x - hr, c.y, c.z + w ),
            float3( c.x + hr, c.y, c.z + w )       
        };
        
        
        // Tesselation Factor 1 
        float3 t1[2] =
        {
            float3( c.x + hw, c.yz ),
            float3( c.x - hw, c.yz )
        };
       
        
        // Hex Indices
        
        // Factor 0
        uint n = 0;
        for ( uint i = 0; i < 5; i += 2 )
        {         
            Vertices[n].pos = verts[i];
            Vertices[n + 1].pos = verts[i + 1];
            Vertices[n + 2].pos = c;
            n += 3;
        }
        Vertices[n].pos = verts[0];
        Vertices[n + 1].pos = verts[5];
        Vertices[n + 2].pos = c;
        
        // Factor 1
        
    }
    
    
    
    
    //uint segments = hexWidth * .5;
    //uint span = hexWidth / segments;
    
    //uint vert = 0;
    
    //uint count = 0;
    //uint stride = 0;
    //HexVertices.GetDimensions( count, stride );
    //// for each vertex in hex buffer
    //for ( uint i = 0; i < count; i++ )
    //{
    //    float3 v = HexVertices[i].pos;
    //    Vertices[vert] = HexVertices[i];
    //    vert++;

    //    for ( uint j = 1; j < segments; j++ )
    //    {
    //        float3 vn = float3( v.x + j * span, v.y, v.z );
    //       // float3 vn = float3( v.x + j * span, v.y, v.z );
    //       // float3 vn = float3( v.x + j * span, v.y, v.z );
            
    //        Vertices[vert].pos = vn;
    //        Vertices[vert].type = HexVertices[i].type;
    //        vert++;
    //    }

    //}
    
    // generate X amount new vertices
    // apply noise for y pos on vertex
    // save new vertices in out buffer
    
    
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
