// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


struct Vertex
{
    float3 pos;
    int type; // = TerrainType
};

struct Hexagon
{
    float3 center;
};



StructuredBuffer<Hexagon> Hex;
StructuredBuffer<Vertex> HexVertices; // IN
RWStructuredBuffer<Vertex> Vertices; // OUT
float HexRadius; // half the total Height
float HexWidth; // Half the total Width


void AddTriangle( inout uint n, float3 a, float3 b, float3 c )
{
    Vertices[n].pos = a;
    Vertices[n + 1].pos = b;
    Vertices[n + 2].pos = c;
    n += 3;
}

void AddTessFullQuad(inout uint n, float3 t, float3 r, float3 d, float3 l, float3 u ) // right, down, left, up with t as middle point
{
    //n = n;
            // t1, 0 , 1 
        // t1, 1, c
        // t1, c, 5
        // t1, 5, 0
    
    Vertices[n].pos = t;
    Vertices[n + 1].pos = r;
    Vertices[n + 2].pos = d;
    n += 3;
    Vertices[n].pos = t;
    Vertices[n + 1].pos = d;
    Vertices[n + 2].pos = l;
    n += 3;
    Vertices[n].pos = t;
    Vertices[n + 1].pos = l;
    Vertices[n + 2].pos = u;
    n += 3;
    Vertices[n].pos = t;
    Vertices[n + 1].pos = u;
    Vertices[n + 2].pos = r;
    n += 3;
}

void AddTessTopHalf(inout uint n, float3 t, float3 r, float3 d, float3 l )
{
                // t4, 5, c
    Vertices[n].pos = t;
    Vertices[n + 1].pos = r;
    Vertices[n + 2].pos = d;
    n += 3;
        // t4, c, 4
    Vertices[n].pos = t;
    Vertices[n + 1].pos = d;
    Vertices[n + 2].pos = l;
    n += 3;

}

void AddTessBottomHalf( inout uint n, float3 t, float3 r, float3 l, float3 u )
{
                // t3, c, 1
    Vertices[n].pos = t;
    Vertices[n + 1].pos = u;
    Vertices[n + 2].pos = r;
    n += 3;
        // t3, 2, c
    Vertices[n].pos = t;
    Vertices[n + 1].pos = l;
    Vertices[n + 2].pos = u;
    n += 3;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    
    // TODO: 
    
    uint n = 0;

    
    
    uint vert = 0;
    
    float r = HexRadius;
    float hr = r * .5;
    
    float w = HexWidth;
    float hw = w * .5;

    // for each center hex tesselate with width / heigth
    uint count = 0;
    uint stride = 0;
    Hex.GetDimensions( count, stride );
    // for each vertex in hex buffer
    for ( uint i = 0; i < count; i++ )
    {
        float3 c = Hex[i].center;
        // Hex Verts
        float3 verts[6] = 
        {
            float3( c.x + r, c.y, c.z ),
            float3( c.x + hr, c.y, c.z - w ),
            float3( c.x - hr, c.y, c.z - w ),
            float3( c.x - r, c.y, c.z ),
            float3( c.x - hr, c.y, c.z + w ),
            float3( c.x + hr, c.y, c.z + w )       
        };
        
        
        // Tesselation Factor 1 
        float3 t1[4] =
        {
            float3( c.x + hw, c.y, c.z ),
            float3( c.x - hw, c.y, c.z ),
            float3( c.x, c.y, c.z - r ),
            float3( c.x, c.y, c.z + r )           
        };
       
        //Vertices[n].pos = t1[0];
        //Vertices[n + 1].pos = verts[0];
        //Vertices[n + 2].pos = verts[1];
        //n += 3;
        
        // Hex Indices
        
        // Factor 0
        //for ( uint j = 0; j < 5; j++ )
        //{         
        //    AddTriangle( n, verts[j], verts[j + 1], c );
        //}
        //AddTriangle( n, verts[0], c, verts[5] );

        // Factor 1
        
        // t1, t2
        
        // t1, 0 , 1 
        // t1, 1, c
        // t1, c, 5
        // t1, 5, 0
        AddTessFullQuad( n, t1[0], verts[0], verts[1], c, verts[5] );
        AddTessFullQuad( n, t1[1], c, verts[2], verts[3], verts[4] );

        AddTessBottomHalf( n, t1[2], verts[1], verts[2], c );
        AddTessTopHalf( n, t1[3], verts[5], c, verts[4] );
        // t2, c, 2
        // t2, 2, 3
        // t2, 3, 4
        // t2, 4, c
        
        // t3, t4
        
        // t3, c, 1
        // t3, 2, c
        // t4, 5, c
        // t4, c, 4
        
    }
    
    
  
    
    
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
